<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UniDrop - Automated Signaling Bridge</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Use a standard font for a clean, modern look -->
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #0d1117; /* Dark background */
            color: #c9d1d9; /* Light text */
        }
        .card {
            background-color: #161b22; /* Card background */
            border: 1px solid #30363d;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
        }
        .btn-primary {
            background-color: #238636;
            color: white;
            transition: background-color 0.15s;
        }
        .btn-primary:hover {
            background-color: #2ea043;
        }
        .btn-secondary {
            background-color: #21262d;
            color: #c9d1d9;
            border: 1px solid #30363d;
            transition: background-color 0.15s;
        }
        .btn-secondary:hover {
            background-color: #30363d;
        }
        .input-text {
            background-color: #0d1117;
            border: 1px solid #30363d;
            color: #c9d1d9;
        }
        /* Custom CSS for the 'Air Throw' animation */
        @keyframes airThrow {
            0% { transform: translate(0, 0) scale(1); opacity: 1; }
            50% { transform: translate(150px, -150px) scale(0.8); opacity: 0.8; }
            100% { transform: translate(300px, -300px) scale(0); opacity: 0; }
        }
        .air-throw-animation {
            animation: airThrow 1s ease-in-out forwards;
            position: fixed;
            z-index: 50;
        }
        /* Custom CSS for the 'Receive Pulse' effect */
        @keyframes receivePulse {
            0% { box-shadow: 0 0 0 0 rgba(45, 160, 67, 0.7); }
            70% { box-shadow: 0 0 0 15px rgba(45, 160, 67, 0); }
            100% { box-shadow: 0 0 0 0 rgba(45, 160, 67, 0); }
        }
        .receive-pulse {
            animation: receivePulse 1.5s ease-out;
        }
    </style>
</head>
<body class="p-4 md:p-8 min-h-screen flex items-start justify-center">

    <div id="app" class="w-full max-w-2xl">
        <header class="text-center mb-10">
            <h1 class="text-4xl font-extrabold text-white mb-2 flex items-center justify-center">
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2.5" stroke="currentColor" class="w-8 h-8 mr-2 text-green-400">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M15.59 14.37a6 6 0 0 1-5.842 1.947m5.842-1.947a6 6 0 0 0-5.842-1.947m5.842 1.947-1.947 5.842m1.947-5.842-1.947-5.842m-3.895 7.789a6 6 0 0 1-5.842 1.947m5.842-1.947a6 6 0 0 0-5.842-1.947m-3.895 7.789-1.947 5.842m1.947-5.842-1.947-5.842m3.895 7.789a6 6 0 0 1-5.842 1.947m5.842-1.947a6 6 0 0 0-5.842-1.947m-3.895 7.789-1.947 5.842m1.947-5.842-1.947-5.842M5.842 14.37a6 6 0 0 1-5.842 1.947m5.842-1.947a6 6 0 0 0-5.842-1.947m-3.895 7.789-1.947 5.842m1.947-5.842-1.947-5.842M3.895 7.789a6 6 0 0 1-5.842 1.947m5.842-1.947a6 6 0 0 0-5.842-1.947m-3.895 7.789-1.947 5.842m1.947-5.842-1.947-5.842" />
                </svg>
                UniDrop
            </h1>
            <p class="text-sm text-gray-400">The fastest way to share files across all your devices.</p>
            <p class="text-xs text-gray-500 mt-1">Triggers AirDrop / QuickShare on compatible devices.</p>
        </header>

        <!-- Main Native Share Button -->
        <div id="native-share-section" class="card p-6 rounded-xl mb-8 text-center">
            <h2 class="text-xl font-semibold mb-4 text-white">1. Native OS Bridge</h2>
            <p class="text-sm text-gray-400 mb-4">Click to select files, and your device's native share menu (QuickShare/AirDrop) will appear.</p>
            <button onclick="document.getElementById('fileInput').click()" 
                    class="btn-primary w-full py-4 text-lg font-bold rounded-lg shadow-lg hover:shadow-green-500/50 transition duration-300">
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2.5" stroke="currentColor" class="w-6 h-6 inline-block mr-2">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M12 4.5v15m0 0 6.75-6.75M12 19.5l-6.75-6.75" />
                </svg>
                Select Files to Share
            </button>
            <input type="file" id="fileInput" multiple style="display:none;" onchange="handleNativeShare(this.files)">
        </div>

        <!-- P2P Fallback Section -->
        <div id="p2p-section" class="card p-6 rounded-xl">
            <h2 class="text-xl font-semibold mb-4 text-white">2. Guaranteed P2P Transfer (Fallback)</h2>
            <p class="text-sm text-gray-400 mb-4">Need to share without native share or when on restricted networks? Use our guaranteed automated room connection.</p>

            <div id="connection-status-info" class="mb-4 p-3 rounded-lg text-center font-medium" :class="{'bg-yellow-900/50 border border-yellow-500': status === 'Disconnected', 'bg-green-900/50 border border-green-500': status === 'Connected'}">
                Status: <span id="status-display" class="font-bold">{{ status }}</span> 
                <span id="user-id-display" class="ml-4 text-xs text-gray-400">ID: {{ userId }}</span>
            </div>

            <div id="data-usage-warning" class="bg-orange-900/50 p-3 rounded-lg text-sm mb-4 border border-orange-500">
                <p class="font-bold text-yellow-300">DATA USAGE REQUIRED:</p>
                <p class="text-yellow-100">Requires a small amount of internet data for the initial **handshake only**. File transfer is 100% local (zero mobile data).</p>
            </div>

            <div class="mb-4">
                <label for="roomName" class="block text-sm font-medium mb-2">1. Enter Shared Room Name/PIN:</label>
                <input type="text" id="roomName" v-model="roomName" placeholder="PARTY-123" class="input-text w-full p-3 rounded-lg text-center text-lg uppercase" @keyup.enter="connectP2P">
            </div>

            <button @click="connectP2P" :disabled="isConnecting"
                    class="btn-primary w-full py-3 text-lg font-bold rounded-lg transition duration-300" :class="{'opacity-50 cursor-not-allowed': isConnecting}">
                {{ isConnecting ? 'Connecting...' : '2. Connect Automatically' }}
            </button>
            <p id="p2p-message" class="text-center mt-3 text-sm text-red-400" v-if="p2pMessage">{{ p2pMessage }}</p>

            <!-- Transfer Controls (Visible on Connection) -->
            <div id="transfer-controls" class="mt-8 pt-4 border-t border-gray-700" v-if="status === 'Connected'">
                <h3 class="text-lg font-semibold mb-4 text-green-400">Transfer Controls (Connected)</h3>

                <!-- File Transfer -->
                <div class="mb-6 card p-4 rounded-xl">
                    <h4 class="font-semibold text-md mb-2">Send Files</h4>
                    <input type="file" id="p2pFileInput" multiple @change="handleP2PFilesSelected" style="display:none;">
                    <button @click="document.getElementById('p2pFileInput').click()" class="btn-secondary w-full py-2 rounded-lg">
                        Select Files for P2P
                    </button>
                    <button @click="sendP2PFiles" :disabled="p2pFiles.length === 0 || isSending"
                            class="btn-primary w-full py-2 mt-2 rounded-lg" :class="{'opacity-50 cursor-not-allowed': p2pFiles.length === 0 || isSending}">
                        {{ isSending ? `Sending... (${sendProgress.toFixed(0)}%)` : `Send ${p2pFiles.length} File(s)` }}
                    </button>
                    <p class="text-xs text-gray-500 mt-2" v-if="p2pFiles.length > 0">Ready to send: {{ p2pFiles.map(f => f.name).join(', ') }}</p>
                </div>

                <!-- Text/Clipboard Transfer -->
                <div class="mb-6 card p-4 rounded-xl">
                    <h4 class="font-semibold text-md mb-2">Send Instant Text/Clipboard</h4>
                    <textarea v-model="instantText" placeholder="Paste text, a link, or a code snippet here."
                              class="input-text w-full p-2 rounded-lg resize-none text-sm h-20 mb-2"></textarea>
                    <button @click="sendInstantText" :disabled="!instantText.trim()" class="btn-primary w-full py-2 rounded-lg"
                            :class="{'opacity-50 cursor-not-allowed': !instantText.trim()}">
                        Send Text Instantly
                    </button>
                </div>
            </div>

            <!-- Received Files List -->
            <div id="received-files-log" class="mt-8 pt-4 border-t border-gray-700">
                <h3 class="text-lg font-semibold mb-4 text-white">Received Items</h3>
                <ul id="log-list">
                    <li v-for="log in logHistory" :key="log.id" :class="log.cssClass" class="p-3 rounded-lg mb-2 flex items-center justify-between text-sm">
                        <span class="truncate">{{ log.icon }} {{ log.message }}</span>
                        <button v-if="log.type === 'text'" @click="copyToClipboard(log.content)" class="btn-secondary px-3 py-1 ml-4 rounded-md text-xs">Copy</button>
                    </li>
                    <li v-if="logHistory.length === 0" class="text-gray-500 text-center py-4">No transfers yet.</li>
                </ul>
            </div>
        </div>
    </div>
    
    <!-- Toast/Modal for messages (no alert/confirm) -->
    <div id="message-modal" class="fixed inset-0 bg-black bg-opacity-70 hidden items-center justify-center p-4 z-50">
        <div class="card p-6 rounded-xl w-full max-w-sm">
            <h3 class="text-xl font-bold mb-4 text-white">UniDrop Message</h3>
            <p id="modal-text" class="mb-6 text-gray-300"></p>
            <button onclick="document.getElementById('message-modal').style.display='none'" class="btn-primary w-full py-2 rounded-lg">Close</button>
        </div>
    </div>
    
    <!-- Load Vue before the custom script -->
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>

    <script>
        // --- Vue.js Setup (Used for reactive UI updates) ---
        const { createApp, ref, reactive } = Vue;

        const app = createApp({
            setup() {
                const status = ref('Disconnected');
                const userId = ref('User-ID');
                const roomName = ref('');
                const isConnecting = ref(false);
                const p2pMessage = ref('');
                const p2pFiles = reactive([]);
                const instantText = ref('');
                const logHistory = reactive([]);
                const sendProgress = ref(0);

                return {
                    status,
                    userId,
                    roomName,
                    isConnecting,
                    p2pMessage,
                    p2pFiles,
                    instantText,
                    logHistory,
                    sendProgress,
                    connectP2P,
                    handleP2PFilesSelected,
                    sendP2PFiles,
                    sendInstantText,
                    copyToClipboard
                };
            }
        }).mount('#app');

        // --- Global P2P Variables ---
        let ws; // WebSocket for signaling
        let peerConnection;
        let dataChannel;
        let fileQueue = [];
        let currentFile = null;
        let fileOffset = 0;
        let chunkSize = 16 * 1024; // 16KB

        // !!! FINAL LIVE RAILWAY URL !!!
        // This URL is secured (wss) and points directly to your deployed signaling server.
        const SIGNALING_SERVER_URL = "wss://bak-production-d2d1.up.railway.app"; 

        const STUN_SERVERS = {
            iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
        };

        // --- Utility Functions ---

        function showMessage(title, text) {
            document.getElementById('modal-text').innerText = text;
            document.getElementById('message-modal').style.display = 'flex';
        }

        function createUserId() {
            return 'User-' + Math.floor(Math.random() * 900) + 100;
        }

        function logTransfer(type, message, content = '') {
            let icon = 'ðŸ“';
            let cssClass = 'bg-gray-800';
            if (type === 'file') {
                icon = 'ðŸ’¾';
                cssClass = 'bg-blue-900/50';
            } else if (type === 'text') {
                icon = 'ðŸ“‹';
                cssClass = 'bg-green-900/50';
            } else if (type === 'system') {
                icon = 'âš™ï¸';
                cssClass = 'bg-gray-800';
            }
            
            app.logHistory.unshift({
                id: Date.now(),
                type: type,
                icon: icon,
                message: message,
                content: content,
                cssClass: cssClass + ' receive-pulse'
            });
            setTimeout(() => {
                const newLog = app.logHistory.find(log => log.id === Date.now());
                if (newLog) newLog.cssClass = newLog.cssClass.replace(' receive-pulse', '');
            }, 1500);
        }

        function copyToClipboard(text) {
            const tempInput = document.createElement('textarea');
            tempInput.value = text;
            document.body.appendChild(tempInput);
            tempInput.select();
            try {
                document.execCommand('copy');
                showMessage('Copied!', 'Text successfully copied to your clipboard.');
            } catch (err) {
                showMessage('Copy Failed', 'Unable to copy text. Please copy manually.');
            }
            document.body.removeChild(tempInput);
        }
        
        // --- Web Share API (Native Share) ---

        async function handleNativeShare(files) {
            if (files.length === 0) return;

            if (navigator.share && navigator.canShare && navigator.canShare({ files: [...files] })) {
                try {
                    await navigator.share({
                        files: [...files],
                        title: 'UniDrop Share',
                        text: 'Shared via UniDrop Bridge',
                    });
                    logTransfer('system', `Successfully triggered native share for ${files.length} file(s).`);
                } catch (error) {
                    if (error.name !== 'AbortError') {
                        showMessage('Share Failed', 'Native sharing failed. You may need to use the P2P Fallback.');
                        logTransfer('system', 'Native share failed: ' + error.message);
                    }
                }
            } else {
                showMessage('Native Share Unavailable', 'Your device or browser does not support the required Native Web Share API. Please use the **Guaranteed P2P Transfer** fallback below.');
            }
        }

        // --- P2P Signaling & Connection Logic (Automated) ---

        // Initialize user ID
        app.userId = createUserId();
        
        function initializeWebSocket() {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.close();
            }

            // The URL is now correct and hardcoded to the live server.
            try {
                ws = new WebSocket(SIGNALING_SERVER_URL);
            } catch (e) {
                app.status = 'Disconnected';
                app.p2pMessage = 'Websocket error. Check URL or ensure server is running.';
                app.isConnecting = false;
                return;
            }

            ws.onopen = () => {
                console.log('WebSocket connected.');
                app.p2pMessage = 'WebSocket connected. Sending join request...';
                
                // 1. Send ID and Room Name to the signaling server
                ws.send(JSON.stringify({
                    type: 'join',
                    room: app.roomName.toUpperCase(),
                    id: app.userId
                }));
            };

            ws.onmessage = handleSignalingMessage;

            ws.onclose = () => {
                console.log('WebSocket disconnected.');
                if (app.status !== 'Connected') {
                    app.status = 'Disconnected';
                    app.p2pMessage = 'Signaling disconnected. Ensure the server is active.';
                }
                app.isConnecting = false;
            };

            ws.onerror = (err) => {
                console.error('WebSocket error:', err);
                app.status = 'Disconnected';
                app.p2pMessage = 'Signaling connection failed. Ensure the server is running and accessible.';
                app.isConnecting = false;
            };
        }

        function connectP2P() {
            if (!app.roomName.trim()) {
                app.p2pMessage = 'Please enter a shared room name.';
                return;
            }
            
            app.isConnecting = true;
            app.p2pMessage = 'Attempting connection... (requires internet access for handshake)';
            initializeWebSocket();
        }

        function handleSignalingMessage(event) {
            const data = JSON.parse(event.data);

            if (data.type === 'peer_joined') {
                // A new peer joined the room. This device is the 'offerer'.
                if (data.id !== app.userId) {
                    app.p2pMessage = `Peer ${data.id} joined. Creating offer...`;
                    initializePeerConnection(true, data.id);
                }
            } else if (data.type === 'offer') {
                // Received an offer. This device is the 'answerer'.
                app.p2pMessage = `Received offer from ${data.senderId}. Creating answer...`;
                    initializePeerConnection(false, data.senderId, data.sdp);
            } else if (data.type === 'answer') {
                // Received an answer to our offer.
                app.p2pMessage = 'Received answer. Finalizing connection...';
                peerConnection.setRemoteDescription(new RTCSessionDescription(data.sdp))
                    .catch(e => console.error('Error setting remote description (answer):', e));
            } else if (data.type === 'ice_candidate') {
                // Received an ICE candidate.
                if (data.candidate) {
                    peerConnection.addIceCandidate(new RTCIceCandidate(data.candidate))
                        .catch(e => console.error('Error adding ICE candidate:', e));
                }
            }
        }

        function initializePeerConnection(isOfferer, remoteId, offerSdp = null) {
            peerConnection = new RTCPeerConnection(STUN_SERVERS);

            peerConnection.onicecandidate = (event) => {
                if (event.candidate) {
                    // Send candidate over the signaling channel
                    ws.send(JSON.stringify({
                        type: 'ice_candidate',
                        room: app.roomName.toUpperCase(),
                        candidate: event.candidate,
                        recipientId: remoteId
                    }));
                }
            };

            peerConnection.ondatachannel = (event) => {
                dataChannel = event.channel;
                setupDataChannel(dataChannel);
            };
            
            peerConnection.onconnectionstatechange = () => {
                console.log('PC State:', peerConnection.connectionState);
                if (peerConnection.connectionState === 'connected') {
                    app.status = 'Connected';
                    app.isConnecting = false;
                    app.p2pMessage = 'P2P Connection established successfully! Transfer is now 100% local.';
                    logTransfer('system', 'P2P connection established with peer.');
                } else if (peerConnection.connectionState === 'failed' || peerConnection.connectionState === 'closed') {
                    app.status = 'Disconnected';
                    app.isConnecting = false;
                    app.p2pMessage = 'P2P connection failed or closed. Try reconnecting.';
                }
            };

            if (isOfferer) {
                dataChannel = peerConnection.createDataChannel('fileChannel');
                setupDataChannel(dataChannel);

                peerConnection.createOffer()
                    .then(offer => peerConnection.setLocalDescription(offer))
                    .then(() => {
                        ws.send(JSON.stringify({
                            type: 'offer',
                            room: app.roomName.toUpperCase(),
                            sdp: peerConnection.localDescription,
                            senderId: app.userId,
                            recipientId: remoteId
                        }));
                    })
                    .catch(e => console.error('Error creating offer:', e));
            } else { // Answerer
                peerConnection.setRemoteDescription(new RTCSessionDescription(offerSdp))
                    .then(() => peerConnection.createAnswer())
                    .then(answer => peerConnection.setLocalDescription(answer))
                    .then(() => {
                        ws.send(JSON.stringify({
                            type: 'answer',
                            room: app.roomName.toUpperCase(),
                            sdp: peerConnection.localDescription,
                            senderId: app.userId,
                            recipientId: remoteId
                        }));
                    })
                    .catch(e => console.error('Error creating answer:', e));
            }
        }

        function setupDataChannel(channel) {
            channel.onopen = () => {
                console.log('Data Channel Open');
                app.status = 'Connected';
                app.isConnecting = false;
            };

            channel.onmessage = handleP2PMessage;

            channel.onclose = () => {
                console.log('Data Channel Closed');
                app.status = 'Disconnected';
            };
            
            // Allow data to be accessed globally for sending
            dataChannel = channel;
        }

        // --- P2P Transfer Logic (Sending) ---

        function handleP2PFilesSelected(event) {
            app.p2pFiles = Array.from(event.target.files);
        }

        function sendP2PFiles() {
            if (app.status !== 'Connected' || app.p2pFiles.length === 0) {
                showMessage('Error', 'Not connected. Please complete the connection handshake.');
                return;
            }

            fileQueue = [...app.p2pFiles]; // Copy files to queue
            sendNextFile();
        }
        
        function sendNextFile() {
            if (fileQueue.length === 0) {
                app.isSending = false;
                app.sendProgress = 100;
                showMessage('Transfer Complete!', 'All files successfully sent over P2P.');
                app.p2pFiles = [];
                document.getElementById('p2pFileInput').value = null; // Reset file input
                return;
            }

            currentFile = fileQueue.shift();
            fileOffset = 0;
            app.isSending = true;
            app.sendProgress = 0;

            // 1. Send file metadata
            const metadata = {
                type: 'file_metadata',
                name: currentFile.name,
                size: currentFile.size,
                fileId: Date.now() + Math.random().toString(36).substring(7)
            };
            dataChannel.send(JSON.stringify(metadata));

            // 2. Start sending chunks
            sendFileChunk();
        }

        function sendFileChunk() {
            if (fileOffset < currentFile.size) {
                const slice = currentFile.slice(fileOffset, fileOffset + chunkSize);
                const reader = new FileReader();

                reader.onload = (e) => {
                    // Send the chunk data (ArrayBuffer)
                    dataChannel.send(e.target.result);
                    
                    fileOffset += e.target.result.byteLength;
                    app.sendProgress = (fileOffset / currentFile.size) * 100;
                    
                    // Throttle sending slightly to avoid data channel buffer overflow
                    if (dataChannel.bufferedAmount < dataChannel.bufferedAmountLowThreshold) {
                        sendFileChunk();
                    } else {
                        dataChannel.onbufferedamountlow = sendFileChunk;
                    }
                };

                reader.readAsArrayBuffer(slice);
            } else {
                // 3. Send transfer completion message
                dataChannel.send(JSON.stringify({ type: 'file_complete' }));
                logTransfer('file', `Sent: ${currentFile.name} (${(currentFile.size / 1024 / 1024).toFixed(2)} MB)`);
                currentFile = null;
                
                // Start next file transfer
                setTimeout(sendNextFile, 100); 
            }
        }

        function sendInstantText() {
            if (app.status !== 'Connected' || !app.instantText.trim()) {
                showMessage('Error', 'Not connected. Please complete the connection handshake.');
                return;
            }

            const textData = {
                type: 'instant_text',
                content: app.instantText,
            };
            
            // Add a temporary animation element
            const transferButton = document.querySelector('#transfer-controls .btn-primary:last-child');
            const flyingIcon = document.createElement('span');
            flyingIcon.textContent = 'ðŸ“‹';
            flyingIcon.className = 'air-throw-animation fixed text-3xl z-10';
            const rect = transferButton.getBoundingClientRect();
            flyingIcon.style.left = `${rect.left + rect.width / 2}px`;
            flyingIcon.style.top = `${rect.top}px`;
            document.body.appendChild(flyingIcon);

            setTimeout(() => {
                flyingIcon.remove();
            }, 1000);

            dataChannel.send(JSON.stringify(textData));
            logTransfer('text', `Sent Text: ${app.instantText.substring(0, 30)}...`);
            app.instantText = ''; // Clear input after sending
        }

        // --- P2P Transfer Logic (Receiving) ---
        let receivedFileBuffers = [];
        let receivingFileMetadata = null;
        
        function handleP2PMessage(event) {
            if (typeof event.data === 'string') {
                // Text data (metadata or instant text)
                const data = JSON.parse(event.data);

                if (data.type === 'file_metadata') {
                    receivingFileMetadata = data;
                    receivedFileBuffers = [];
                    logTransfer('system', `Receiving file: ${data.name} (${(data.size / 1024 / 1024).toFixed(2)} MB)...`);
                } else if (data.type === 'file_complete') {
                    const receivedBlob = new Blob(receivedFileBuffers, { type: 'application/octet-stream' });
                    downloadFile(receivedBlob, receivingFileMetadata.name);
                    logTransfer('file', `Received: ${receivingFileMetadata.name} successfully.`);
                    receivingFileMetadata = null;
                } else if (data.type === 'instant_text') {
                    logTransfer('text', `Received Text: ${data.content.substring(0, 50)}...`, data.content);
                }
            } else if (event.data instanceof ArrayBuffer) {
                // Binary data (file chunk)
                if (receivingFileMetadata) {
                    receivedFileBuffers.push(event.data);
                }
            }
        }

        function downloadFile(blob, filename) {
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.style.display = 'none';
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // --- Initialization ---

        window.onload = () => {
            if (!RTCPeerConnection) {
                showMessage('Error', 'Your browser does not support the WebRTC technology required for P2P transfer.');
                return;
            }
            app.userId = createUserId();
            app.roomName = 'PARTY-' + Math.floor(Math.random() * 900) + 100;
        };
    </script>
</body>
</html>
