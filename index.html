<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UniDrop | Zero-Paste P2P Bridge</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- QR Code Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script> 
    
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #0d1117; 
            color: #c9d1d9;
        }
        .app-container {
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 2rem 1rem;
        }
        .card {
            background-color: #161b22;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            max-width: 600px;
            width: 100%;
        }
        /* Custom button for main action */
        .btn-main {
            background-color: #4f46e5; /* Indigo */
            color: white;
            transition: background-color 0.2s;
            box-shadow: 0 4px 10px rgba(79, 70, 229, 0.4);
        }
        .btn-main:hover {
            background-color: #4338ca;
        }
        .input-style {
            background-color: #21262d;
            border: 1px solid #30363d;
            color: #c9d1d9;
            padding: 0.75rem;
            border-radius: 0.5rem;
            font-size: 0.9rem;
        }
        /* Fallback P2P buttons */
        .btn-p2p {
            background-color: #1f2937; /* Gray 800 */
            color: #9ca3af; /* Gray 400 */
            border: 1px solid #374151; /* Gray 700 */
        }
        .btn-p2p:hover {
            background-color: #374151;
            color: white;
        }
        .qr-placeholder {
            min-height: 200px;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #21262d;
            border-radius: 0.5rem;
        }
        #qrcode-offer img, #qrcode-answer img {
            margin: auto;
        }
    </style>
</head>
<body>

<div class="app-container">
    <div class="card p-6 md:p-8 rounded-xl">
        <h1 class="text-3xl font-extrabold text-center mb-2 text-white flex items-center justify-center">
            <svg class="w-8 h-8 mr-2 text-indigo-400" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z"></path></svg>
            UniDrop
        </h1>
        <p class="text-center text-sm mb-8 text-gray-400">The fastest way to share files across all your devices.</p>

        <!-- Status Message Box -->
        <div id="message-box" class="p-4 mb-6 rounded-lg hidden"></div>

        <!-- File Input (Hidden, used to trigger file selection) -->
        <input type="file" id="file-input" multiple class="hidden">

        <!-- Main Action Button: Native Share First -->
        <button id="main-share-btn" class="btn-main w-full py-4 rounded-xl text-xl font-bold flex items-center justify-center transition transform hover:scale-[1.01] duration-200">
            <svg class="w-6 h-6 mr-3" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"></path></svg>
            Select Files to Share
        </button>
        <p class="text-center text-xs mt-2 text-gray-500">Triggers AirDrop / QuickShare on compatible devices.</p>

        <!-- P2P Fallback Trigger -->
        <button id="show-p2p-setup-btn" class="w-full py-2 mt-6 rounded-lg text-sm font-medium btn-p2p flex items-center justify-center">
             <svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
            Troubleshoot Connection (100% Offline P2P)
        </button>


        <!-- P2P Connection Setup Section (Hidden by default) -->
        <div id="p2p-setup-section" class="hidden mt-6 p-6 rounded-xl bg-gray-800/50">
            <h2 class="text-xl font-semibold mb-4 text-white">Universal P2P Handshake (Zero-Paste Flow)</h2>

            <!-- Connection Status -->
            <div class="p-3 rounded-lg bg-gray-700/30 mb-4 flex justify-between items-center text-sm">
                <span>Status: <span id="connection-status" class="font-bold text-red-500">Disconnected</span></span>
                <span class="font-mono text-gray-400 text-xs">ID: <span id="local-peer-id">...</span></span>
            </div>
            
            <div class="space-y-4">
                
                <!-- Step 1: Generate Offer -->
                <div id="offer-step">
                    <button id="create-offer-btn" class="w-full py-3 btn-main rounded-lg text-md font-medium bg-green-600 hover:bg-green-700">
                        1. Generate Offer QR (Sender)
                    </button>
                    <div id="qrcode-offer" class="qr-placeholder mt-3 hidden">
                        <p class="text-sm text-gray-400">Scan this code with the Receiver device.</p>
                    </div>
                    <p id="offer-status" class="text-xs text-yellow-400 mt-2 hidden text-center">Gathering network data (5s)...</p>
                </div>

                <div class="text-center text-gray-500 font-bold py-2">--- SCAN & EXCHANGE ---</div>
                
                <!-- Step 2 & 3: Scan and Process -->
                <div id="answer-step">
                    <h3 class="text-lg font-semibold mb-2 text-white">Input/Scan Code:</h3>
                    
                    <!-- We use a hidden input for the user to manually paste the scanned code -->
                    <textarea id="signal-input-code" rows="1" placeholder="Paste the scanned code here. (Zero-Paste is recommended)" class="w-full input-style text-xs h-0 p-0 overflow-hidden"></textarea>

                    <button id="generate-answer-btn" class="w-full py-3 bg-purple-600 rounded-lg text-md font-medium hover:bg-purple-700 transition text-white">
                        2. Process Offer & Generate Answer QR (Receiver)
                    </button>

                    <div id="qrcode-answer" class="qr-placeholder mt-3 hidden">
                        <p class="text-sm text-gray-400">Show this Answer QR to the Sender device.</p>
                    </div>
                    
                    <button id="receive-answer-btn" class="w-full py-3 bg-indigo-600 rounded-lg text-md font-medium hover:bg-indigo-700 transition text-white mt-4 hidden">
                        3. Finalize Connection (Sender)
                    </button>
                    
                    <!-- Hidden Text Areas (for code storage/debugging) -->
                    <textarea id="offer-code-text" class="hidden"></textarea>
                    <textarea id="answer-code-text" class="hidden"></textarea>
                </div>
            </div>
        </div>

        <!-- Transfer Controls (Visible once P2P connected) -->
        <div id="transfer-controls" class="hidden mt-6 p-6 rounded-xl bg-gray-800/50">
            <h2 class="text-2xl font-semibold mb-4 text-white">P2P Link Active! Start Transfer.</h2>

            <div class="space-y-6">
                <!-- File Transfer -->
                <div>
                    <h3 class="text-xl font-semibold mb-3 flex items-center text-green-400">
                        File Transfer
                    </h3>
                    <!-- This button is only shown when P2P is connected AND a file is selected (from the main share button) -->
                    <button id="p2p-send-files-btn" class="w-full py-2 btn-main rounded-lg text-md font-semibold bg-indigo-600 hover:bg-indigo-700">
                        Send Selected Files via P2P
                    </button>
                    <div id="p2p-file-status" class="text-xs text-gray-400 italic mt-2">No files selected.</div>
                    
                    <!-- Transfer Progress Bar -->
                    <div id="transfer-progress" class="hidden p-3 rounded-lg bg-green-900/40 mt-4">
                        <p class="text-sm font-medium mb-1 text-green-300">Transferring: <span id="current-file-name"></span></p>
                        <div class="w-full bg-gray-700 rounded-full h-2">
                            <div id="progress-bar" class="bg-green-500 h-2 rounded-full" style="width: 0%"></div>
                        </div>
                        <p id="progress-text" class="text-xs text-right mt-1 text-green-400">0%</p>
                    </div>
                </div>

                <!-- Instant Text -->
                <div>
                    <h3 class="text-xl font-semibold mb-3 flex items-center text-blue-400">
                        Instant Text/Clipboard
                    </h3>
                    <textarea id="text-input" rows="2" class="w-full input-style text-sm" placeholder="Paste link or text to send instantly..."></textarea>
                    <button id="send-text-button" class="w-full py-2 rounded-lg font-semibold transition bg-purple-600 hover:bg-purple-700 text-white mt-2">
                        Send Instant Text
                    </button>
                </div>
            </div>
            
            <!-- History (Local to this session only) -->
            <div class="mt-8 pt-6 border-t border-gray-700">
                <h2 class="text-xl font-semibold mb-4">Transfer History</h2>
                <div id="history-list" class="space-y-3 h-48 overflow-y-auto pr-2">
                    <p class="text-gray-500 italic">No transfers yet.</p>
                </div>
            </div>
        </div>

    </div>
</div>

<!-- --- JAVASCRIPT LOGIC --- -->
<script>
    // --- GLOBAL VARIABLES & CONSTANTS ---
    let localPeerId = crypto.randomUUID();
    let userName = 'User-' + localPeerId.substring(0, 4);
    let peerConnection = null;
    let dataChannel = null;
    let fileMeta = {}; 
    let history = []; 
    
    // Using Google's public STUN server to help peers discover their public IP, crucial for P2P connection
    const RTC_CONFIG = {
        iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
    };
    
    // --- DOM ELEMENTS ---
    const localPeerIdEl = document.getElementById('local-peer-id');
    const connectionStatusEl = document.getElementById('connection-status');
    const messageBoxEl = document.getElementById('message-box');
    const transferControlsEl = document.getElementById('transfer-controls');
    const setupControlsEl = document.getElementById('p2p-setup-section');
    const p2pFileStatusEl = document.getElementById('p2p-file-status');
    const p2pSendFilesBtn = document.getElementById('p2p-send-files-btn'); 
    
    // Mode & Main Action Buttons
    const mainShareBtn = document.getElementById('main-share-btn');
    const fileInput = document.getElementById('file-input');
    const showP2PSetupBtn = document.getElementById('show-p2p-setup-btn');
    
    // P2P Setup
    const createOfferBtn = document.getElementById('create-offer-btn');
    const qrcodeOfferEl = document.getElementById('qrcode-offer');
    const qrcodeAnswerEl = document.getElementById('qrcode-answer');
    const offerStatusEl = document.getElementById('offer-status');
    const signalInputCodeEl = document.getElementById('signal-input-code');
    const generateAnswerBtn = document.getElementById('generate-answer-btn');
    const receiveAnswerBtn = document.getElementById('receive-answer-btn');
    // Hidden text areas for code storage/debugging
    const offerCodeTextEl = document.getElementById('offer-code-text');
    const answerCodeTextEl = document.getElementById('answer-code-text');
    
    // Transfer Controls
    const textInputEl = document.getElementById('text-input');
    const sendTextBtn = document.getElementById('send-text-button');
    const transferProgressEl = document.getElementById('transfer-progress');
    const progressBar = document.getElementById('progress-bar');
    const progressText = document.getElementById('progress-text');
    const currentFileNameEl = document.getElementById('current-file-name');
    const historyListEl = document.getElementById('history-list');

    // --- UTILITIES ---

    function displayMessage(message, type) {
        messageBoxEl.textContent = message;
        messageBoxEl.classList.remove('hidden', 'bg-red-900/40', 'bg-green-900/40', 'bg-blue-900/40', 'text-red-300', 'text-green-300', 'text-blue-300');
        
        messageBoxEl.className = 'p-4 mb-6 rounded-lg';
        switch(type) {
            case 'success':
                messageBoxEl.classList.add('bg-green-900/40', 'text-green-300');
                break;
            case 'error':
                messageBoxEl.classList.add('bg-red-900/40', 'text-red-300');
                break;
            case 'info':
            default:
                messageBoxEl.classList.add('bg-blue-900/40', 'text-blue-300');
                break;
        }

        setTimeout(() => {
            if (messageBoxEl.textContent === message) {
                messageBoxEl.classList.add('hidden');
            }
        }, 5000);
    }
    
    function blobToArrayBuffer(blob) {
        return new Promise((resolve) => {
            const reader = new FileReader();
            reader.onloadend = () => resolve(reader.result);
            reader.readAsArrayBuffer(blob);
        });
    }

    // --- QR CODE GENERATION ---
    function generateQrCode(elementId, text) {
        const element = document.getElementById(elementId);
        element.innerHTML = ''; // Clear previous QR code
        
        // This is a common pattern for qrcode.js initialization
        new QRCode(elementId, {
            text: text,
            width: 200,
            height: 200,
            colorDark : "#ffffff",
            colorLight : "#161b22",
            correctLevel : QRCode.CorrectLevel.M // Increased level for long SDP data
        });
        element.classList.remove('hidden');
    }

    // --- MAIN ACTION FLOW ---

    mainShareBtn.addEventListener('click', () => {
        fileInput.click();
    });

    fileInput.addEventListener('change', () => {
        const files = Array.from(fileInput.files);
        if (files.length === 0) {
            displayMessage('No files selected.', 'info');
            p2pFileStatusEl.textContent = 'No files selected.';
            return;
        }

        const isConnected = dataChannel && dataChannel.readyState === 'open';
        p2pFileStatusEl.innerHTML = `<span class="text-green-400 font-semibold">${files.length} file(s) ready.</span> ${isConnected ? 'Click P2P button to send.' : 'Connect P2P for local transfer.'}`;

        // Attempt Native Share First
        if (navigator.share && navigator.canShare && navigator.canShare({ files: files })) {
            navigator.share({
                files: files,
                title: 'UniDrop Share',
                text: `Sharing ${files.length} file(s) via UniDrop native bridge.`
            }).then(() => {
                displayMessage(`Native Share sheet opened. Look for QuickShare or AirDrop devices now!`, 'success');
            }).catch((error) => {
                console.error('Native sharing failed or cancelled:', error);
                displayMessage('Native sharing failed or was cancelled. Try the 100% Offline P2P mode below.', 'error');
            });
        } else {
            displayMessage('Native file sharing is not fully supported on this device. Using 100% Offline P2P mode is recommended.', 'error');
            // Check if P2P section is hidden, and if so, simulate a click on the fallback button
            if(setupControlsEl.classList.contains('hidden')) {
                 showP2PSetupBtn.click(); 
            }
        }
    });


    // --- P2P FALLBACK SETUP (Zero-Paste QR) ---

    showP2PSetupBtn.addEventListener('click', () => {
        mainShareBtn.classList.add('hidden');
        showP2PSetupBtn.classList.add('hidden');
        setupControlsEl.classList.remove('hidden');
        
        connectionStatusEl.textContent = 'Disconnected';
        connectionStatusEl.classList.replace('text-green-500', 'text-red-500');
        transferControlsEl.classList.add('hidden');
        displayMessage('P2P Mode enabled. Follow the steps: 1. Generate QR, 2. Scan & Process, 3. Scan & Finalize.', 'info');
        
        document.dispatchEvent(new Event('p2p_status_changed'));
        
        // Reset QR/Input display
        qrcodeOfferEl.classList.add('hidden');
        qrcodeAnswerEl.classList.add('hidden');
        createOfferBtn.classList.remove('hidden');
        generateAnswerBtn.classList.remove('hidden');
        receiveAnswerBtn.classList.add('hidden');
    });

    p2pSendFilesBtn.addEventListener('click', sendFilesViaP2P);

    async function createPeerConnection(isInitiator) {
        if (peerConnection) {
            peerConnection.close();
            peerConnection = null;
            dataChannel = null;
        }

        peerConnection = new RTCPeerConnection(RTC_CONFIG);
        
        peerConnection.onicecandidate = ({ candidate }) => {};

        peerConnection.oniceconnectionstatechange = () => {
            document.dispatchEvent(new Event('p2p_status_changed'));
            
            if (peerConnection.iceConnectionState === 'connected') {
                connectionStatusEl.textContent = 'Connected';
                connectionStatusEl.classList.replace('text-red-500', 'text-green-500');
                transferControlsEl.classList.remove('hidden');
                setupControlsEl.classList.add('hidden');
                displayMessage('P2P Connection established! You are ready to share.', 'success');
            } else if (peerConnection.iceConnectionState === 'failed' || peerConnection.iceConnectionState === 'disconnected' || peerConnection.iceConnectionState === 'closed') {
                 connectionStatusEl.textContent = 'Disconnected';
                 connectionStatusEl.classList.replace('text-green-500', 'text-red-500');
                 transferControlsEl.classList.add('hidden');
                 if (setupControlsEl.classList.contains('hidden')) {
                     setupControlsEl.classList.remove('hidden');
                 }
                 displayMessage('P2P connection lost or failed. Restart connection process.', 'error');
            }
        };

        if (isInitiator) {
            dataChannel = peerConnection.createDataChannel('dataChannel', { ordered: true, maxRetransmits: 0 });
            setupDataChannelListeners(dataChannel);
        } else {
            peerConnection.ondatachannel = (event) => {
                dataChannel = event.channel;
                setupDataChannelListeners(dataChannel);
            };
        }
    }

    async function createOffer() {
        qrcodeAnswerEl.classList.add('hidden'); 
        qrcodeOfferEl.innerHTML = `<p class="text-sm text-gray-400">Generating Offer...</p>`;
        qrcodeOfferEl.classList.remove('hidden');

        await createPeerConnection(true);
        const offer = await peerConnection.createOffer();
        await peerConnection.setLocalDescription(offer);

        displayMessage('Gathering candidates... please wait 5 seconds before displaying QR.', 'info');
        offerStatusEl.classList.remove('hidden');
        await new Promise(resolve => setTimeout(resolve, 5000)); 
        offerStatusEl.classList.add('hidden');

        const offerPayload = JSON.stringify({ sdp: peerConnection.localDescription });
        offerCodeTextEl.value = offerPayload;
        
        generateQrCode('qrcode-offer', offerPayload);
        createOfferBtn.classList.add('hidden');
        
        displayMessage('Offer QR generated (Step 1 Complete). Scan this code with the receiver device.', 'success');
    }

    createOfferBtn.addEventListener('click', createOffer);

    async function generateAnswer() {
        // Step 1: Wait for the user to scan the OFFER QR code and paste (zero-paste)
        let offerPayload;
        try {
            offerPayload = await navigator.clipboard.readText();
        } catch (e) {
            // Fallback for browsers without clipboard access initiated by user action
             displayMessage("Clipboard access failed. Please manually paste the code into the text area first.", 'error');
             return;
        }

        signalInputCodeEl.value = offerPayload; // Used for processing, but invisible to user (since textarea is hidden)

        if (!offerPayload || offerPayload.length < 100) {
            displayMessage("Please scan the Offer QR code on the Sender's screen and ensure it is copied to your clipboard, then try again.", 'error');
            return;
        }
        
        qrcodeOfferEl.classList.add('hidden');
        qrcodeAnswerEl.innerHTML = `<p class="text-sm text-gray-400">Processing Offer...</p>`;
        qrcodeAnswerEl.classList.remove('hidden');

        try {
            const { sdp } = JSON.parse(offerPayload);

            await createPeerConnection(false);
            await peerConnection.setRemoteDescription(new RTCSessionDescription(sdp));

            const answer = await peerConnection.createAnswer();
            await peerConnection.setLocalDescription(answer);
            
            await new Promise(resolve => setTimeout(resolve, 3000));
            
            const answerPayload = JSON.stringify({ sdp: peerConnection.localDescription });
            answerCodeTextEl.value = answerPayload;

            generateQrCode('qrcode-answer', answerPayload);
            signalInputCodeEl.value = ''; // Clear input for next step

            generateAnswerBtn.classList.add('hidden');
            receiveAnswerBtn.classList.remove('hidden');

            displayMessage('Answer QR generated (Step 2 Complete). Show this QR to the sender.', 'success');
        } catch (e) {
            console.error("Error generating answer:", e);
            displayMessage("Error processing code. Make sure you scanned the correct QR.", 'error');
        }
    }
    
    generateAnswerBtn.addEventListener('click', generateAnswer);

    async function receiveAnswer() {
        // Step 1: Wait for the user to scan the ANSWER QR code and paste (zero-paste)
        let answerPayload;
        try {
            answerPayload = await navigator.clipboard.readText();
        } catch (e) {
            // Fallback for browsers without clipboard access initiated by user action
             displayMessage("Clipboard access failed. Please manually paste the code into the text area first.", 'error');
             return;
        }
        
        signalInputCodeEl.value = answerPayload; // Used for processing, but invisible to user

        if (!answerPayload || answerPayload.length < 100) {
            displayMessage("Please scan the Answer QR code on the Receiver's screen and ensure it is copied to your clipboard, then try again.", 'error');
            return;
        }

        try {
            const { sdp } = JSON.parse(answerPayload);

            await peerConnection.setRemoteDescription(new RTCSessionDescription(sdp));
            displayMessage(`Answer received (Step 3 Complete). Connecting...`, 'info');
            
            // Cleanup UI (will be hidden entirely once connected)
            signalInputCodeEl.value = '';
            
        } catch (e) {
            console.error("Error receiving answer:", e);
            displayMessage("Error processing code. Make sure you scanned the correct QR.", 'error');
        }
    }

    receiveAnswerBtn.addEventListener('click', receiveAnswer);

    // --- DATACAHNNEL & MESSAGING ---

    function setupDataChannelListeners(channel) {
        channel.onopen = () => {
            displayMessage('Data Channel Open! Secure P2P pipe established.', 'success');
            document.dispatchEvent(new Event('p2p_status_changed'));
        };

        channel.onclose = () => {
             document.dispatchEvent(new Event('p2p_status_changed'));
        };

        channel.onmessage = (event) => {
            if (typeof event.data === 'string') {
                try {
                    const message = JSON.parse(event.data);
                    handleIncomingP2PMessage(message);
                } catch (e) {
                    console.warn("Received non-JSON string chunk data.");
                }
            } else {
                handleFileChunk(event.data);
            }
        };
    }

    function handleIncomingP2PMessage(message) {
        switch (message.type) {
            case 'FILE_CHUNK_META':
                handleFileChunkMetadata(message);
                break;
            case 'FILE_END':
                handleFileEnd();
                break;
            case 'TEXT_MESSAGE':
                handleReceivedText(message);
                break;
            default:
                console.warn('Unknown message type:', message.type);
        }
    }
    
    function send(message) {
        if (dataChannel && dataChannel.readyState === 'open') {
            dataChannel.send(JSON.stringify(message));
            return true;
        }
        displayMessage("P2P Data Channel is not open. Connection failed or lost.", 'error');
        return false;
    }

    // --- P2P FILE TRANSFER LOGIC (Called manually via P2P mode) ---

    async function sendFilesViaP2P() {
        const files = Array.from(fileInput.files);
        if (files.length === 0 || !dataChannel || dataChannel.readyState !== 'open') {
            displayMessage("No files selected or P2P connection not ready.", 'error');
            return;
        }

        const totalSize = files.reduce((sum, file) => sum + file.size, 0);

        const historyItem = {
            type: 'FILE_BUNDLE',
            sender: userName,
            content: `${files.length} file(s) total: ${(totalSize / (1024 * 1024)).toFixed(2)} MB`,
            files: files.map(f => ({ name: f.name, size: f.size })),
            timestamp: Date.now(),
        };
        saveHistory(historyItem);
        
        fileMeta.filesToSend = files;
        fileMeta.currentFileIndex = 0;
        
        sendNextFile();
    }

    async function sendNextFile() {
        if (fileMeta.currentFileIndex >= fileMeta.filesToSend.length) {
            displayMessage('All files sent successfully!', 'success');
            transferProgressEl.classList.add('hidden');
            return;
        }

        const file = fileMeta.filesToSend[fileMeta.currentFileIndex];
        const chunkSize = 16 * 1024; // 16KB chunk size
        let offset = 0;

        send({ type: 'FILE_CHUNK_META', file: { name: file.name, size: file.size, type: file.type } });
        
        const fileBuffer = await blobToArrayBuffer(file);
        
        while (offset < file.size) {
            const chunk = fileBuffer.slice(offset, offset + chunkSize);
            dataChannel.send(new Uint8Array(chunk));
            offset += chunk.byteLength;
            
            const progress = (offset / file.size) * 100;
            currentFileNameEl.textContent = file.name;
            progressBar.style.width = `${progress}%`;
            progressText.textContent = `${Math.round(progress)}%`;
            transferProgressEl.classList.remove('hidden');
            
            // Backpressure control: Wait if the buffer is full
            if (dataChannel.bufferedAmount > dataChannel.bufferedAmountLowThreshold) {
                await new Promise(r => dataChannel.onbufferedamountlow = r);
            }
        }
        
        send({ type: 'FILE_END', fileName: file.name });
        
        fileMeta.currentFileIndex++;
        sendNextFile();
    }
    
    function handleFileChunkMetadata(message) {
        fileMeta.currentFile = message.file;
        fileMeta.receivedSize = 0;
        fileMeta.chunks = [];
        
        currentFileNameEl.textContent = message.file.name;
        progressBar.style.width = '0%';
        progressText.textContent = '0%';
        transferProgressEl.classList.remove('hidden');
        displayMessage(`Receiving file: ${message.file.name}`, 'info');
    }

    function handleFileChunk(chunk) {
        if (!fileMeta.currentFile) return;

        fileMeta.chunks.push(chunk);
        fileMeta.receivedSize += chunk.byteLength;

        const progress = (fileMeta.receivedSize / fileMeta.currentFile.size) * 100;
        progressBar.style.width = `${progress}%`;
        progressText.textContent = `${Math.round(progress)}%`;
    }

    function handleFileEnd() {
        if (!fileMeta.currentFile) return;

        const file = new Blob(fileMeta.chunks, { type: fileMeta.currentFile.type });
        const url = URL.createObjectURL(file);
        
        // Use a hidden anchor tag to trigger the file download
        const a = document.createElement('a');
        a.href = url;
        a.download = fileMeta.currentFile.name;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);

        displayMessage(`File received and downloaded: ${fileMeta.currentFile.name}`, 'success');
        transferProgressEl.classList.add('hidden');
        
        saveHistory({
            type: 'FILE_BUNDLE',
            sender: 'Remote Peer',
            content: `Received: ${fileMeta.currentFile.name}`,
            files: [{ name: fileMeta.currentFile.name, size: fileMeta.currentFile.size }],
            timestamp: Date.now(),
        });

        fileMeta = {};
    }

    // --- INSTANT TEXT LOGIC ---

    sendTextBtn.addEventListener('click', () => {
        const text = textInputEl.value.trim();
        if (!text) {
            displayMessage("Text input is empty.", 'error');
            return;
        }

        if (send({ type: 'TEXT_MESSAGE', content: text })) {
            saveHistory({
                type: 'TEXT',
                sender: userName,
                content: text,
                timestamp: Date.now(),
            });
            displayMessage('Text sent instantly.', 'success');
            textInputEl.value = '';
        }
    });

    function handleReceivedText(message) {
         saveHistory({
            type: 'TEXT',
            sender: 'Remote Peer',
            content: message.content,
            timestamp: Date.now(),
        });
        displayMessage(`Instant text received!`, 'info');
    }

    // --- HISTORY (LOCAL) ---

    function saveHistory(data) {
        history.push(data);
        renderHistory();
    }

    function renderHistory() {
        historyListEl.innerHTML = '';

        history.forEach((item) => {
            const isSender = item.sender === userName;
            const color = isSender ? 'bg-green-900/40 border-green-700' : 'bg-blue-900/40 border-blue-700';
            const senderName = isSender ? 'You' : 'Remote Peer';
            
            let iconHtml;
            let contentHtml = item.content;

            if (item.type === 'FILE_BUNDLE') {
                iconHtml = `<svg class="w-4 h-4 inline mr-1 text-green-400" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 7v10a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-6l-2-2H5a2 2 0 00-2 2z"></path></svg>`;
                const fileNames = (item.files || []).map(f => `<span class="italic">${f.name}</span> (${(f.size / (1024 * 1024)).toFixed(1)}MB)`).join('<br>');
                contentHtml = `<p class="font-bold">${item.content}</p>
                    <div class="text-xs text-gray-400 mt-1 pl-2 border-l border-gray-600">${fileNames}</div>`;
            } else if (item.type === 'TEXT') {
                iconHtml = `<svg class="w-4 h-4 inline mr-1 text-purple-400" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 15l-2 5L9 9l5-2 5-2m-2-5l4 4"></path></svg>`;
                contentHtml = `<p class="whitespace-pre-wrap">${item.content}</p>`;
            }

            const div = document.createElement('div');
            div.className = `p-3 border rounded-lg text-sm ${color}`;
            div.innerHTML = `
                <div class="flex justify-between items-start mb-1">
                    <span class="font-semibold text-white">${iconHtml} ${senderName}</span>
                    <span class="text-xs text-gray-500">${new Date(item.timestamp).toLocaleTimeString()}</span>
                </div>
                <div>${contentHtml}</div>
            `;
            historyListEl.appendChild(div);
        });
        
        historyListEl.scrollTop = historyListEl.scrollHeight;
    }

    // --- INITIALIZATION ---
    document.addEventListener('DOMContentLoaded', () => {
        localPeerIdEl.textContent = `${userName}`;
        setupControlsEl.classList.add('hidden');
        p2pSendFilesBtn.classList.add('hidden'); 

        // Listener to capture clipboard content for the P2P handshake
        document.addEventListener('paste', async (e) => {
            if (setupControlsEl.classList.contains('hidden')) return; // Only process paste in P2P mode
            
            e.preventDefault();
            
            try {
                const pastedText = e.clipboardData.getData('text');
                if (pastedText && pastedText.length > 100) { 
                    signalInputCodeEl.value = pastedText; // Store the scanned/pasted code

                    // Automatically trigger the next step based on which button is visible
                    if (!generateAnswerBtn.classList.contains('hidden')) {
                         generateAnswerBtn.click();
                    } else if (!receiveAnswerBtn.classList.contains('hidden')) {
                         receiveAnswerBtn.click();
                    }
                }
            } catch (error) {
                console.error("Paste failed:", error);
                displayMessage("Paste failed. Please ensure your QR scanner copies the text to the clipboard.", 'error');
            }
        });

        // Event listener to show/hide the P2P Send button based on connection status
        document.addEventListener('p2p_status_changed', () => {
             const filesSelected = fileInput.files.length > 0;
             const isConnected = dataChannel && dataChannel.readyState === 'open';

             if (isConnected) {
                 p2pSendFilesBtn.classList.toggle('hidden', !filesSelected);
             } else {
                 p2pSendFilesBtn.classList.add('hidden');
             }
        });
        
        // Listener to update P2P status and show/hide the send button after file selection
        fileInput.addEventListener('change', () => {
            const filesSelected = fileInput.files.length > 0;
            const isConnected = dataChannel && dataChannel.readyState === 'open';
            
            if (filesSelected && isConnected) {
                p2pSendFilesBtn.classList.remove('hidden');
            } else {
                 p2pSendFilesBtn.classList.add('hidden');
            }

            if (filesSelected) {
                 p2pFileStatusEl.innerHTML = `<span class="text-green-400 font-semibold">${fileInput.files.length} file(s) selected.</span> Click button to send via P2P.`;
            } else {
                 p2pFileStatusEl.textContent = 'No files selected.';
            }
        });
    });

</script>

</body>
</html>
