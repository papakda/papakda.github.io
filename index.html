<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UniDrop - Red Edition</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&family=JetBrains+Mono:wght@500&display=swap" rel="stylesheet">
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        // SPIDER-MAN THEME üï∑Ô∏èüî¥‚ö´
                        background: '#000000', 
                        foreground: '#ffffff',
                        card: '#0a0a0a',       
                        border: '#1a1a1a',
                        muted: '#171717',
                        'muted-foreground': '#a1a1aa',
                        primary: '#ef4444',    // Bright Red
                        'primary-foreground': '#ffffff',
                        success: '#ef4444',    // Red for success too (monochrome feel)
                        warning: '#f59e0b',
                    },
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                        mono: ['JetBrains Mono', 'monospace'],
                    },
                    animation: {
                        'pulse-fast': 'pulse 1.5s cubic-bezier(0.4, 0, 0.6, 1) infinite',
                    }
                }
            }
        }
    </script>
    <style>
        body { background: #050505; color: #fff; }
        .glass-card {
            background: linear-gradient(135deg, rgba(20, 20, 20, 0.9), rgba(10, 10, 10, 0.95));
            border: 1px solid rgba(239, 68, 68, 0.2); /* Red Border */
            backdrop-filter: blur(20px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.8);
        }
        .glow-primary {
            box-shadow: 0 0 20px rgba(239, 68, 68, 0.3), 0 0 40px rgba(239, 68, 68, 0.1);
        }
        .btn-hero {
            background: linear-gradient(135deg, #ef4444, #b91c1c);
            transition: transform 0.2s, box-shadow 0.2s;
        }
        .btn-hero:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(239, 68, 68, 0.4);
        }
        .input-field {
            background: #0a0a0a;
            border: 1px solid #262626;
            color: white;
        }
        .input-field:focus {
            outline: none;
            border-color: #ef4444;
            box-shadow: 0 0 0 2px rgba(239, 68, 68, 0.2);
        }
    </style>
</head>
<body class="min-h-screen p-4 md:p-8 flex items-center justify-center">

    <div id="app" class="w-full max-w-2xl">
        <header class="text-center mb-8">
            <h1 class="text-5xl font-extrabold tracking-tighter mb-2">
                UNI<span class="text-primary">DROP</span>
            </h1>
            <p class="text-muted-foreground text-sm">Secure P2P File Bridge</p>
        </header>

        <main class="glass-card rounded-2xl p-6 md:p-8 relative overflow-hidden">
            <div class="absolute top-0 left-0 w-full h-1 bg-gradient-to-r from-transparent via-primary to-transparent opacity-50" v-if="status === 'Connected'"></div>

            <div v-if="status === 'Disconnected'" class="space-y-4 animate-in fade-in slide-in-from-bottom-4 duration-500">
                <div class="text-center space-y-2">
                    <div class="inline-block p-4 rounded-full bg-primary/10 mb-2">
                        <svg class="w-8 h-8 text-primary" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z"/></svg>
                    </div>
                    <h2 class="text-xl font-bold">Connect to Room</h2>
                    <p class="text-sm text-muted-foreground">Enter a unique ID to find peers.</p>
                </div>
                
                <input v-model="roomName" @keyup.enter="connect" placeholder="ROOM-NAME" class="input-field w-full p-4 text-center text-2xl font-mono uppercase rounded-xl tracking-widest">
                
                <button @click="connect" :disabled="isConnecting" class="btn-hero w-full py-4 rounded-xl font-bold text-lg text-white disabled:opacity-50">
                    {{ isConnecting ? 'Connecting...' : 'Join Network' }}
                </button>
            </div>

            <div v-else class="space-y-6">
                <div class="flex items-center justify-between bg-muted/30 p-3 rounded-lg border border-border">
                    <div class="flex items-center gap-3">
                        <span class="relative flex h-3 w-3">
                          <span class="animate-ping absolute inline-flex h-full w-full rounded-full bg-primary opacity-75"></span>
                          <span class="relative inline-flex rounded-full h-3 w-3 bg-primary"></span>
                        </span>
                        <span class="font-mono text-sm text-primary font-bold">{{ roomName }}</span>
                    </div>
                    <div class="text-xs text-muted-foreground font-mono">ID: {{ userId }}</div>
                    <button @click="disconnect" class="text-xs text-red-400 hover:text-red-300 underline">Disconnect</button>
                </div>

                <div class="bg-black/20 p-4 rounded-xl border border-border">
                    <h3 class="text-xs font-bold text-muted-foreground uppercase tracking-wider mb-3">Active Peers</h3>
                    <div class="flex flex-wrap gap-2" v-if="Object.keys(peers).length > 0">
                        <span v-for="peerId in Object.keys(peers)" :key="peerId" class="bg-primary/20 text-primary border border-primary/30 px-3 py-1 rounded-full text-xs font-mono flex items-center gap-2">
                            <span class="w-1.5 h-1.5 bg-primary rounded-full"></span> {{ peerId }}
                        </span>
                    </div>
                    <p v-else class="text-sm text-muted-foreground italic">Waiting for others to join {{ roomName }}...</p>
                </div>

                <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <div class="p-4 rounded-xl bg-muted/10 border border-border hover:border-primary/50 transition-colors">
                        <input type="file" id="fileInput" multiple class="hidden" @change="handleFileSelect">
                        <button onclick="document.getElementById('fileInput').click()" class="w-full py-8 border-2 border-dashed border-muted-foreground/30 rounded-lg hover:border-primary text-muted-foreground hover:text-primary transition-all mb-3 flex flex-col items-center gap-2">
                            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"/></svg>
                            <span>Select Files</span>
                        </button>
                        
                        <div v-if="selectedFiles.length" class="space-y-2">
                            <div class="text-xs text-white bg-card p-2 rounded border border-border truncate">
                                {{ selectedFiles.length }} file(s) selected
                            </div>
                            <button @click="sendFiles" :disabled="isSending || Object.keys(peers).length === 0" class="btn-hero w-full py-2 rounded-lg font-bold text-sm text-white disabled:opacity-50">
                                {{ isSending ? `Sending ${sendProgress.toFixed(0)}%` : 'Send Now' }}
                            </button>
                        </div>
                    </div>

                    <div class="p-4 rounded-xl bg-muted/10 border border-border hover:border-primary/50 transition-colors flex flex-col">
                        <textarea v-model="textToSend" placeholder="Paste links or text..." class="input-field w-full flex-1 p-3 rounded-lg text-sm mb-3 resize-none bg-black/50"></textarea>
                        <button @click="sendText" :disabled="!textToSend.trim() || Object.keys(peers).length === 0" class="btn-hero w-full py-2 rounded-lg font-bold text-sm text-white disabled:opacity-50">
                            Send Text
                        </button>
                    </div>
                </div>
            </div>

            <div class="mt-6 border-t border-border pt-4">
                <h3 class="text-xs font-bold text-muted-foreground uppercase tracking-wider mb-3">Activity Log</h3>
                <div class="space-y-2 max-h-40 overflow-y-auto pr-2 custom-scrollbar font-mono text-xs">
                    <div v-for="log in logs" :key="log.id" class="flex items-start gap-2 text-muted-foreground">
                        <span class="text-primary">[{{ new Date(log.id).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'}) }}]</span>
                        <span :class="{'text-white': log.type === 'file', 'text-blue-400': log.type === 'text'}">{{ log.message }}</span>
                    </div>
                    <div v-if="logs.length === 0" class="text-muted-foreground/30 italic">No activity yet.</div>
                </div>
            </div>
        </main>
    </div>

    <div id="toast" class="fixed bottom-6 right-6 bg-card border border-primary text-white px-6 py-4 rounded-xl shadow-2xl transform transition-all duration-300 translate-y-20 opacity-0 z-50 flex items-center gap-3">
        <span class="text-xl">üï∑Ô∏è</span>
        <p id="toastMessage" class="font-bold"></p>
    </div>

    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <script>
        const { createApp, ref, reactive } = Vue;

        // --- Configuration ---
        // ‚úÖ UPDATED: Connected to your live Render server (wss://)
        const SIGNALING_URL = 'wss://bak-2zcx.onrender.com';
        const STUN_SERVERS = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] };
        const CHUNK_SIZE = 16 * 1024; // 16KB

        // --- Helper: Toast ---
        function showToast(msg) {
            const t = document.getElementById('toast');
            document.getElementById('toastMessage').innerText = msg;
            t.classList.remove('translate-y-20', 'opacity-0');
            setTimeout(() => t.classList.add('translate-y-20', 'opacity-0'), 3000);
        }

        createApp({
            setup() {
                // State
                const status = ref('Disconnected');
                const isConnecting = ref(false);
                const userId = ref('USER-' + Math.floor(Math.random() * 1000));
                const roomName = ref('HQ-1'); // Default Room
                const peers = reactive({}); // { peerId: { connection, channel } }
                const logs = reactive([]);
                
                // Transfer State
                const selectedFiles = ref([]);
                const textToSend = ref('');
                const sendProgress = ref(0);
                const isSending = ref(false);
                const receivedBuffers = {}; // For reassembling files

                let ws = null;
                let fileQueue = [];
                let currentFile = null;
                let fileOffset = 0;

                // --- Logging ---
                function addLog(type, message) {
                    logs.unshift({ id: Date.now(), type, message });
                }

                // --- 1. WebSocket Signaling ---
                function connect() {
                    if (!roomName.value) return;
                    isConnecting.value = true;
                    status.value = 'Connecting...';

                    ws = new WebSocket(SIGNALING_URL);

                    ws.onopen = () => {
                        ws.send(JSON.stringify({ type: 'join', room: roomName.value, id: userId.value }));
                        status.value = 'Connected';
                        isConnecting.value = false;
                        addLog('system', `Connected to Signaling Server as ${userId.value}`);
                    };

                    ws.onmessage = async (msg) => {
                        const data = JSON.parse(msg.data);
                        if (data.type === 'peer_joined') {
                            addLog('system', `New peer joined: ${data.id}`);
                            initPeer(data.id, true); // Initiator
                        } else if (data.type === 'offer') {
                            if (!peers[data.senderId]) initPeer(data.senderId, false);
                            await peers[data.senderId].connection.setRemoteDescription(data.sdp);
                            const answer = await peers[data.senderId].connection.createAnswer();
                            await peers[data.senderId].connection.setLocalDescription(answer);
                            ws.send(JSON.stringify({ type: 'answer', recipientId: data.senderId, sdp: answer }));
                        } else if (data.type === 'answer') {
                            await peers[data.senderId].connection.setRemoteDescription(data.sdp);
                        } else if (data.type === 'ice_candidate') {
                            if (peers[data.senderId]) {
                                peers[data.senderId].connection.addIceCandidate(data.candidate);
                            }
                        }
                    };

                    ws.onclose = () => {
                        status.value = 'Disconnected';
                        isConnecting.value = false;
                        addLog('system', 'Disconnected from server.');
                        Object.keys(peers).forEach(p => delete peers[p]);
                    };
                }

                function disconnect() {
                    if (ws) ws.close();
                }

                // --- 2. WebRTC Peer Connection ---
                function initPeer(remoteId, isInitiator) {
                    const pc = new RTCPeerConnection(STUN_SERVERS);
                    peers[remoteId] = { connection: pc, channel: null };

                    pc.onicecandidate = (e) => {
                        if (e.candidate) {
                            ws.send(JSON.stringify({ type: 'ice_candidate', recipientId: remoteId, candidate: e.candidate, senderId: userId.value }));
                        }
                    };

                    // Data Channel Logic
                    if (isInitiator) {
                        const dc = pc.createDataChannel("data");
                        setupDataChannel(dc, remoteId);
                        peers[remoteId].channel = dc;
                        
                        pc.createOffer().then(offer => {
                            pc.setLocalDescription(offer);
                            ws.send(JSON.stringify({ type: 'offer', recipientId: remoteId, sdp: offer, senderId: userId.value }));
                        });
                    } else {
                        pc.ondatachannel = (e) => {
                            setupDataChannel(e.channel, remoteId);
                            peers[remoteId].channel = e.channel;
                        };
                    }
                }

                function setupDataChannel(dc, remoteId) {
                    dc.onopen = () => addLog('system', `Direct connection opened with ${remoteId}`);
                    dc.onmessage = (e) => handleDataMessage(e, remoteId);
                }

                // --- 3. Sending Logic ---
                function handleFileSelect(e) {
                    if (e.target.files) selectedFiles.value = Array.from(e.target.files);
                }

                function sendFiles() {
                    if (selectedFiles.value.length === 0) return;
                    fileQueue = [...selectedFiles.value];
                    isSending.value = true;
                    processFileQueue();
                }

                function processFileQueue() {
                    if (fileQueue.length === 0) {
                        isSending.value = false;
                        selectedFiles.value = [];
                        showToast('All files sent!');
                        return;
                    }
                    currentFile = fileQueue.shift();
                    fileOffset = 0;
                    
                    // Broadcast Metadata
                    const meta = { type: 'meta', name: currentFile.name, size: currentFile.size, fileId: Date.now() };
                    broadcast(JSON.stringify(meta));
                    addLog('file', `Starting send: ${currentFile.name}`);
                    
                    // Start Chunking
                    readSlice();
                }

                function readSlice() {
                    const slice = currentFile.slice(fileOffset, fileOffset + CHUNK_SIZE);
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        broadcast(e.target.result); // Send ArrayBuffer
                        fileOffset += e.target.result.byteLength;
                        sendProgress.value = (fileOffset / currentFile.size) * 100;

                        if (fileOffset < currentFile.size) {
                            // Backpressure check (prevent crashing chrome)
                            const slowestPeer = Object.values(peers).reduce((max, p) => Math.max(max, p.channel?.bufferedAmount || 0), 0);
                            if (slowestPeer > 64 * 1024) {
                                setTimeout(readSlice, 50);
                            } else {
                                setTimeout(readSlice, 0);
                            }
                        } else {
                            broadcast(JSON.stringify({ type: 'end_file', fileId: Date.now() })); // End marker
                            setTimeout(processFileQueue, 100);
                        }
                    };
                    reader.readAsArrayBuffer(slice);
                }

                function sendText() {
                    if (!textToSend.value) return;
                    broadcast(JSON.stringify({ type: 'text', content: textToSend.value }));
                    addLog('text', `Sent: ${textToSend.value}`);
                    textToSend.value = '';
                    showToast('Text sent!');
                }

                function broadcast(data) {
                    Object.values(peers).forEach(p => {
                        if (p.channel && p.channel.readyState === 'open') p.channel.send(data);
                    });
                }

                // --- 4. Receiving Logic ---
                function handleDataMessage(e, remoteId) {
                    const data = e.data;
                    
                    if (typeof data === 'string') {
                        const msg = JSON.parse(data);
                        if (msg.type === 'meta') {
                            receivedBuffers[remoteId] = { meta: msg, buffer: [] };
                            addLog('file', `Receiving ${msg.name}...`);
                        } else if (msg.type === 'end_file') {
                            const fileData = receivedBuffers[remoteId];
                            if (fileData) {
                                const blob = new Blob(fileData.buffer);
                                const url = URL.createObjectURL(blob);
                                const a = document.createElement('a');
                                a.href = url;
                                a.download = fileData.meta.name;
                                a.click();
                                addLog('file', `Received ${fileData.meta.name}`);
                                showToast(`File received: ${fileData.meta.name}`);
                                delete receivedBuffers[remoteId];
                            }
                        } else if (msg.type === 'text') {
                            addLog('text', `Received: ${msg.content}`);
                            navigator.clipboard.writeText(msg.content);
                            showToast('Text copied to clipboard!');
                        }
                    } else {
                        // Binary Chunk
                        if (receivedBuffers[remoteId]) {
                            receivedBuffers[remoteId].buffer.push(data);
                        }
                    }
                }

                return {
                    status, isConnecting, userId, roomName, peers, logs,
                    selectedFiles, textToSend, sendProgress, isSending,
                    connect, disconnect, handleFileSelect, sendFiles, sendText
                };
            }
        }).mount('#app');
    </script>
</body>
</html>
